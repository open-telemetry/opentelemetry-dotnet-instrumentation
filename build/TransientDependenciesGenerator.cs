using DependencyListGenerator;
using Microsoft.Build.Construction;
using Nuke.Common.ProjectModel;
using Serilog;

internal static class TransientDependenciesGenerator
{
    private const string NetFrameworkFamilyLabel = "all .NET Framework";
    private const string NetCoreFamilyLabel = "all .NET (Core)";
    private const string NetFrameworkCondition = " '$(TargetFrameworkIdentifier)' == '.NETFramework' ";
    private const string NetCoreCondition = " '$(TargetFrameworkIdentifier)' == '.NETCoreApp' ";

    private static string GetLabel(string frameworkOrFamily) =>
        frameworkOrFamily != null
            ? $"Transient dependencies auto-generated by {nameof(TransientDependenciesGenerator)} for {frameworkOrFamily}"
            : $"Transient dependencies auto-generated by {nameof(TransientDependenciesGenerator)}";

    private static (string PackageName, string PackageVersion) GetPackageProperties(ProjectElement item) =>
        item is ProjectItemElement { ElementName: "PackageVersion" } pkgRef
            ? (pkgRef.Include, pkgRef.Metadata.FirstOrDefault(it => it.Name == "Version")?.Value)
            : (null, null);

    private static void AddPackageReference(ProjectItemGroupElement items, string packageName, string packageVersion)
    {
        var reference = items.AddItem("PackageVersion", packageName);
        reference.AddMetadata("Version", packageVersion, expressAsAttribute: true);
    }

    private static ProjectItemGroupElement GetOrCreateItemGroup(
        Microsoft.Build.Evaluation.Project packagesProject,
        string label,
        string condition = null)
    {
        var group = packagesProject.Xml.ItemGroups.FirstOrDefault(x => x.Label == label);
        if (group == null)
        {
            group = packagesProject.Xml.AddItemGroup();
            group.Label = label;
            if (condition != null)
            {
                group.Condition = condition;
            }
        }
        return group;
    }

    private static void CleanUnusedDependencies(
        string label,
        IEnumerable<TransientDependency> validDependencies,
        Microsoft.Build.Evaluation.Project packagesProject)
    {
        var versionGroup = packagesProject.Xml.ItemGroups.FirstOrDefault(x => x.Label == label);

        if (versionGroup == null)
        {
            return;
        }

        var validDepsSet = validDependencies
            .Select(d => (d.Name, d.Version))
            .ToHashSet();

        foreach (var pkg in versionGroup.Children.ToArray())
        {
            var pkgProp = GetPackageProperties(pkg);
            if (pkgProp.PackageName == null || pkgProp.PackageVersion == null)
            {
                continue;
            }

            if (!validDepsSet.Contains((pkgProp.PackageName, pkgProp.PackageVersion)))
            {
                versionGroup.RemoveChild(pkg);
            }
        }
    }

    private static void MoveCommonDependenciesToGroup(
        Microsoft.Build.Evaluation.Project packagesProject,
        IReadOnlyCollection<string> targetFrameworks,
        string groupLabel,
        string groupCondition = null)
    {
        if (targetFrameworks.Count == 0)
        {
            return;
        }

        var targetGroup = GetOrCreateItemGroup(packagesProject, groupLabel, groupCondition);
        var frameworkGroups = targetFrameworks
            .Select(fw => packagesProject.Xml.ItemGroups.First(x => x.Label == GetLabel(fw)))
            .ToList();

        var candidatePackages = frameworkGroups[0].Children
            .Select(GetPackageProperties)
            .Where(pkg => pkg.PackageName != null && pkg.PackageVersion != null)
            .ToArray();

        foreach (var pkg in candidatePackages)
        {
            var existsInAllFrameworks = frameworkGroups
                .All(group => group.Children.OfType<ProjectItemElement>()
                    .Any(it => GetPackageProperties(it) == pkg));

            if (existsInAllFrameworks)
            {
                foreach (var group in frameworkGroups)
                {
                    var reference = group.Children.OfType<ProjectItemElement>()
                        .First(it => GetPackageProperties(it) == pkg);
                    group.RemoveChild(reference);
                }

                AddPackageReference(targetGroup, pkg.PackageName, pkg.PackageVersion);
            }
        }
    }

    public static void Run(Project targetProject)
    {
        var project = targetProject.GetMSBuildProject();
        var deps = Generator.EnumerateDependencies(project.FullPath);
        var packages = targetProject.Solution.Directory / "src" / Projects.AutoInstrumentationAssemblies /
                       "Directory.Packages.props";
        var packagesProject = ProjectModelTasks.ParseProject(packages);

        var projectFrameworks = targetProject.GetTargetFrameworks();

        if (projectFrameworks == null || projectFrameworks.Count == 0)
        {
            Log.Error(
                $"Project {targetProject.Name} does not specify any target frameworks. Skipping {nameof(TransientDependenciesGenerator)} step.");
            return;
        }

        // Generate new transitive dependencies for each framework
        foreach (var framework in projectFrameworks)
        {
            var label = GetLabel(framework);
            var projectForTfm = targetProject.GetMSBuildProject(targetFramework: framework);
            var definedVersions = projectForTfm
                .Items.Where(it => it.ItemType == "PackageVersion")
                .ToDictionary(item => item.EvaluatedInclude, item => item.GetMetadata("Version"));

            var versionGroup = GetOrCreateItemGroup(packagesProject, label, $" '$(TargetFramework)' == '{framework}' ");

            if (deps.TryGetValue(framework, out var frameworkDeps))
            {
                foreach (var item in frameworkDeps)
                {
                    if (!definedVersions.ContainsKey(item.Name))
                    {
                        AddPackageReference(versionGroup, item.Name, item.Version);
                    }
                }
            }
        }

        // Group frameworks by family
        var netFrameworkTargets = projectFrameworks
            .Where(target => TargetFramework.NetFramework.Any(it => it == target))
            .ToList();
        var netCoreTargets = projectFrameworks
            .Where(target => TargetFramework.Net.Any(it => it == target))
            .ToList();

        // Optimize dependencies in hierarchical order (general to specific):
        // 1. Common across ALL frameworks
        // 2. Common within .NET Framework family
        // 3. Common within .NET (Core) family
        // 4. Framework-specific (already in individual groups)

        MoveCommonDependenciesToGroup(packagesProject, projectFrameworks, GetLabel(null));

        if (netFrameworkTargets.Count > 1)
        {
            MoveCommonDependenciesToGroup(
                packagesProject,
                netFrameworkTargets,
                GetLabel(NetFrameworkFamilyLabel),
                NetFrameworkCondition);
        }

        if (netCoreTargets.Count > 1)
        {
            MoveCommonDependenciesToGroup(
                packagesProject,
                netCoreTargets,
                GetLabel(NetCoreFamilyLabel),
                NetCoreCondition);
        }

        // Clean up unused dependencies from all groups
        foreach (var framework in projectFrameworks)
        {
            if (deps.TryGetValue(framework, out var frameworkDeps))
            {
                CleanUnusedDependencies(GetLabel(framework), frameworkDeps, packagesProject);
            }
        }

        CleanUnusedDependencies(GetLabel(null), deps.Values.SelectMany(d => d), packagesProject);

        if (netFrameworkTargets.Count > 0)
        {
            var netFrameworkDeps = netFrameworkTargets.SelectMany(it => deps.TryGetValue(it, out var value) ? value : []);
            CleanUnusedDependencies(GetLabel(NetFrameworkFamilyLabel), netFrameworkDeps, packagesProject);
        }

        if (netCoreTargets.Count > 0)
        {
            var netCoreDeps = netCoreTargets.SelectMany(it => deps.TryGetValue(it, out var value) ? value : []);
            CleanUnusedDependencies(GetLabel(NetCoreFamilyLabel), netCoreDeps, packagesProject);
        }

        packagesProject.Save();
    }
}
