using DependencyListGenerator;
using Microsoft.Build.Construction;
using Nuke.Common.ProjectModel;
using Serilog;

internal static class TransientDependenciesGenerator
{
    private static string GetLabel(string framework) =>
        framework != null
            ? $"Transient dependencies auto-generated by {nameof(TransientDependenciesGenerator)} for {framework}"
            : $"Transient dependencies auto-generated by {nameof(TransientDependenciesGenerator)}";

    private static (string PackageName, string PackageVersion) GetPackageProperties(ProjectElement item) =>
        item is ProjectItemElement { ElementName: "PackageVersion" } pkgRef
            ? (pkgRef.Include,
                pkgRef.Metadata.FirstOrDefault(it => it.Name == "Version")?.Value)
            : (null, null);

    private static void AddPackageReference(ProjectItemGroupElement items, string packageName, string packageVersion)
    {
        var reference = items.AddItem("PackageVersion", packageName);
        reference.AddMetadata("Version", packageVersion, expressAsAttribute: true);
    }

    private static void CleanUnusedDependencies(string framework, Dictionary<string, TransientDependency[]> deps, Microsoft.Build.Evaluation.Project packagesProject)
    {
        var label = GetLabel(framework);
        var versionGroup = packagesProject.Xml.ItemGroups.First(x => x.Label == label);

        foreach (var pkg in versionGroup.Children.ToArray())
        {
            var pkgProp = GetPackageProperties(pkg);
            if (pkgProp.PackageName == null || pkgProp.PackageVersion == null)
            {
                continue;
            }

            var dependencyExists = (framework == null ? deps.SelectMany(kvp => kvp.Value) : deps[framework])
                .Any(item => item.Name == pkgProp.PackageName && item.Version == pkgProp.PackageVersion);

            if (!dependencyExists)
            {
                versionGroup.RemoveChild(pkg);
            }
        }
    }

    public static void Run(Project targetProject)
    {
        var project = targetProject.GetMSBuildProject();
        var deps = Generator.EnumerateDependencies(project.FullPath);
        var packages = targetProject.Solution.Directory / "src" / Projects.AutoInstrumentationAssemblies /
                       "Directory.Packages.props";
        var packagesProject = ProjectModelTasks.ParseProject(packages);

        var projectFrameworks = targetProject.GetTargetFrameworks();

        if (projectFrameworks == null || projectFrameworks.Count == 0)
        {
            Log.Error(
                $"Project {targetProject.Name} does not specify any target frameworks. Skipping {nameof(TransientDependenciesGenerator)} step.");
            return;
        }

        // generate new transitive dependencies
        foreach (var framework in projectFrameworks)
        {
            var label = GetLabel(framework);

            var projectForTfm = targetProject.GetMSBuildProject(targetFramework: framework);
            var definedVersions = projectForTfm
                .Items.Where(it => it.ItemType == "PackageVersion").ToDictionary(item => item.EvaluatedInclude,
                    item => item.GetMetadata("Version"));

            var versionGroup = packagesProject.Xml.ItemGroups.FirstOrDefault(x => x.Label == label);
            if (versionGroup == null)
            {
                versionGroup = packagesProject.Xml.AddItemGroup();
                versionGroup.Label = label;
                versionGroup.Condition = $" '$(TargetFramework)' == '{framework}' ";
            }

            foreach (var item in deps[framework])
            {
                if (!definedVersions.ContainsKey(item.Name))
                {
                    AddPackageReference(versionGroup, item.Name, item.Version);
                }
            }
        }

        // TODO after extending to .net (core) this doesn't do anything, need to group by family: .net frameworks vs .net (core)
        //group dependencies
        {
            var commonLabel = GetLabel(null);
            var commonGroup = packagesProject.Xml.ItemGroups.FirstOrDefault(x => x.Label == commonLabel);
            if (commonGroup == null)
            {
                commonGroup = packagesProject.Xml.AddItemGroup();
                commonGroup.Label = commonLabel;
            }

            var someFramework = projectFrameworks.First();
            var allFrameworkGroups = targetProject.GetTargetFrameworks()!.Select(GetLabel)
                .Select(label => packagesProject.Xml.ItemGroups.First(x => x.Label == label)).ToArray();

            var label = GetLabel(someFramework);
            var versionGroup = packagesProject.Xml.ItemGroups.First(x => x.Label == label);

            var packageVersionsToProcess = versionGroup.Children
                .Select(GetPackageProperties)
                .Where(pkg => pkg.PackageName != null && pkg.PackageVersion != null)
                .ToArray();

            foreach (var pkg in packageVersionsToProcess)
            {
                var existsInAllFrameworks = allFrameworkGroups
                    .All(group => group.Children.OfType<ProjectItemElement>()
                        .Any(it => GetPackageProperties(it) == pkg));

                if (existsInAllFrameworks)
                {
                    foreach (var group in allFrameworkGroups)
                    {
                        var reference = group.Children.OfType<ProjectItemElement>()
                            .First(it => GetPackageProperties(it) == pkg);
                        group.RemoveChild(reference);
                    }

                    AddPackageReference(commonGroup, pkg.PackageName, pkg.PackageVersion);
                }
            }
        }

        // clean unused dependencies
        foreach (var framework in targetProject.GetTargetFrameworks() ?? [])
        {
            CleanUnusedDependencies(framework, deps, packagesProject);
        }

        CleanUnusedDependencies(null, deps, packagesProject);

        packagesProject.Save();
    }
}
