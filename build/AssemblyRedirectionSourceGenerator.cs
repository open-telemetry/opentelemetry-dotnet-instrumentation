using System.Text;
using System.Text.RegularExpressions;
using Mono.Cecil;
using Serilog;

public static class AssemblyRedirectionSourceGenerator
{
    public static void Generate(
        string assembliesFolderPath,
        string generatedFilePath,
        Regex versionRegex,
        Func<GroupCollection, string> versionNormalizer)
    {
        Log.Debug("Generating assembly redirection file {0}", generatedFilePath);

        var macroName = Path.GetFileNameWithoutExtension(generatedFilePath).ToUpperInvariant();

        var assemblies = new SortedDictionary<int, SortedDictionary<string, AssemblyNameDefinition>>();

        var folders = new Dictionary<int, string>();

        // Discover framework-specific subfolders
        foreach (var directory in Directory.EnumerateDirectories(assembliesFolderPath))
        {
            var folderName = Path.GetFileName(directory);
            var framework = versionNormalizer(versionRegex.Match(folderName).Groups);
            if (framework == string.Empty)
            {
                Log.Error("Unexpected folder name: {0}, will not be processed", framework);
                continue;
            }
            var frameworkVersion = int.Parse(framework);

            if (folders.TryGetValue(frameworkVersion, out var folder))
            {
                Log.Error("For {0}: already registered folder {1}, {2} will be skipped", frameworkVersion, folder, directory);
                continue;
            }
            folders[frameworkVersion] = directory;
            assemblies[frameworkVersion] = new SortedDictionary<string, AssemblyNameDefinition>();
        }

        void Process(string fileName, int? framework)
        {
            try
            {
                using var moduleDef = ModuleDefinition.ReadModule(fileName);
                var assemblyDef = moduleDef.Assembly.Name!;
                if (assemblyDef.Name == "netstandard")
                {
                    // Skip netstandard, since it doesn't need redirection.
                    return;
                }

                foreach (var keys in framework != null ? (IEnumerable<int>)[framework.Value] : assembliesFolderPath.Keys)
                {
                    assemblies[keys][assemblyDef.Name] = assemblyDef;
                    Log.Debug("Adding {0} assembly to the redirection map {1}. Targeted version {2}", assemblyDef.Name,
                        keys, assemblyDef.Version);
                }
            }
            catch (BadImageFormatException)
            {
                Log.Debug("Skipping \"{0}\" couldn't open it as a managed assembly", fileName);
            }
        }

        // Process common assemblies in root folder
        foreach (var fileName in Directory.EnumerateFiles(assembliesFolderPath))
        {
            Process(fileName, null);
        }

        // Process framework-specific assemblies
        foreach (var fx in folders)
        {
            foreach (var fileName in Directory.EnumerateFiles(fx.Value))
            {
                var filenameToProcess = fileName;
                if (Path.GetExtension(fileName) == ".link")
                {
                    filenameToProcess = Path.Combine(assembliesFolderPath, File.ReadAllText(fileName),
                        Path.GetFileNameWithoutExtension(fileName));
                }

                Process(filenameToProcess, fx.Key);
            }
        }

        var sourceContents = GenerateSourceContents(assemblies, macroName);

        File.WriteAllText(generatedFilePath, sourceContents);
        Log.Information("Assembly redirection source generated {0}", generatedFilePath);
    }

    private static string GenerateSourceContents(SortedDictionary<int, SortedDictionary<string, AssemblyNameDefinition>> assemblies, string macroName)
    {
        #pragma warning disable format
        return
        $$"""
        /*
         * Copyright The OpenTelemetry Authors
         * SPDX-License-Identifier: Apache-2.0
         */

        // Auto-generated file, do not change it - generated by the {{nameof(AssemblyRedirectionSourceGenerator)}} type

        // Macro to handle cross-platform UTF-16 string literals
        #ifdef _WIN32
        #define _W(s) L##s
        #else
        #define _W(s) u##s
        #endif

        #define {{macroName}} \
            {{GenerateEntries(assemblies)}}

        """;
        #pragma warning restore format
    }

    private static string GenerateEntries(SortedDictionary<int, SortedDictionary<string, AssemblyNameDefinition>> frameworks)
    {
        var sb = new StringBuilder();

        foreach (var fx in frameworks)
        {
            sb.AppendLine($"    {{ {fx.Key}, {{ \\");
            foreach (var kvp in fx.Value)
            {
                var v = kvp.Value.Version!;
                if (kvp.Key != "OpenTelemetry.AutoInstrumentation")
                {
                    sb.AppendLine($"        {{ _W(\"{kvp.Key}\"), {{{v.Major}, {v.Minor}, {v.Build}, {v.Revision}}} }}, \\");
                }
                else
                {
                    sb.AppendLine($"        {{ _W(\"{kvp.Key}\"), {{auto_major, 0, 0, 0}} }}, \\");
                }
            }
            sb.AppendLine("    }}, \\");
        }

        return sb.ToString()
            .AsSpan() // Optimisation for following string manipulations
            .Trim() // Remove whitespaces
            .TrimEnd(", \\") // Remove trailing comma
            .ToString();
    }
}
