using System.Collections;
using System.Text;
using System.Text.RegularExpressions;
using Mono.Cecil;
using Serilog;

public static class AssemblyRedirectionSourceGenerator
{
    public static void Generate(string assembliesFolderPath, string generatedFilePath)
    {
        Log.Debug("Generating assembly redirection file {0}", generatedFilePath);
        var assemblies = new SortedDictionary<int, SortedDictionary<string, AssemblyNameDefinition>>();

        var folders = new Dictionary<int, string>();

        var frameworkVersionRegEx = new Regex(@"^net(?<version>\d{2,3})$");
        foreach (var directory in Directory.EnumerateDirectories(assembliesFolderPath))
        {
            var folderName = Path.GetFileName(directory);
            var framework = frameworkVersionRegEx.Match(folderName).Groups["version"].Value;
            if (framework == string.Empty)
            {
                Log.Error("Unexpected folder name: {0}, will not be processed", framework);
                continue;
            }
            var frameworkVersion = int.Parse(framework);
            if (frameworkVersion < 100)
            {
                frameworkVersion *= 10;
            }

            if (folders.TryGetValue(frameworkVersion, out var folder))
            {
                Log.Error("For {0}: already registered folder {1}, {2} will be skipped", frameworkVersion, folder, directory);
                continue;
            }
            folders[frameworkVersion] = directory;
            assemblies[frameworkVersion] = new SortedDictionary<string, AssemblyNameDefinition>();
        }

        void Process(string fileName, int? framework)
        {
            try
            {
                using var moduleDef = ModuleDefinition.ReadModule(fileName);
                var assemblyDef = moduleDef.Assembly.Name!;
                if (assemblyDef.Name == "netstandard")
                {
                    // Skip netstandard, since it doesn't need redirection.
                    return;
                }


                foreach (var keys in framework != null ? (IEnumerable<int>)[framework.Value] : assemblies.Keys)
                {
                    assemblies[keys][assemblyDef.Name] = assemblyDef;
                    Log.Debug("Adding {0} assembly to the redirection map {1}. Targeted version {2}", assemblyDef.Name,
                        keys, assemblyDef.Version);
                }
            }
            catch (BadImageFormatException)
            {
                Log.Debug("Skipping \"{0}\" couldn't open it as a managed assembly", fileName);
            }
        }

        foreach (var fileName in Directory.EnumerateFiles(assembliesFolderPath))
        {
            Process(fileName, null);

        }

        foreach (var fx in folders)
        {
            foreach (var fileName in Directory.EnumerateFiles(fx.Value))
            {
                var filenameToProcess = fileName;
                if (Path.GetExtension(fileName) == "link")
                {
                    filenameToProcess = Path.Combine(generatedFilePath, File.ReadAllText(fileName),
                        Path.GetFileNameWithoutExtension(fileName));
                }

                Process(filenameToProcess, fx.Key);
            }
        }

        var sourceContents = GenerateSourceContents(assemblies);

        File.WriteAllText(generatedFilePath, sourceContents);
        Log.Information("Assembly redirection source generated {0}", generatedFilePath);
    }

    private static string GenerateSourceContents(SortedDictionary<int, SortedDictionary<string, AssemblyNameDefinition>> assemblies)
    {
        #pragma warning disable format
        return
        $$"""
        /*
         * Copyright The OpenTelemetry Authors
         * SPDX-License-Identifier: Apache-2.0
         */

        // Auto-generated file, do not change it - generated by the {{nameof(AssemblyRedirectionSourceGenerator)}} type

        #include "cor_profiler.h"

        #ifdef _WIN32
        #define STR(Z1) #Z1
        #define AUTO_MAJOR STR(OTEL_AUTO_VERSION_MAJOR) 
        
        namespace trace
        {
        void CorProfiler::InitNetFxAssemblyRedirectsMap()
        {
            const USHORT auto_major = atoi(AUTO_MAJOR);

            assembly_version_redirect_map_.insert({
                {{GenerateEntries(assemblies)}}
            });
        }
        }
        #endif

        """;
        #pragma warning restore format
    }

    private static string GenerateEntries(SortedDictionary<int, SortedDictionary<string, AssemblyNameDefinition>> frameworks)
    {
        var sb = new StringBuilder();

        foreach (var fx in frameworks)
        {
            sb.AppendLine($"        {{ {fx.Key}, {{");
            foreach (var kvp in fx.Value)
            {
                var v = kvp.Value.Version!;
                if (kvp.Key != "OpenTelemetry.AutoInstrumentation")
                {
                    sb.AppendLine($"            {{ L\"{kvp.Key}\", {{{v.Major}, {v.Minor}, {v.Build}, {v.Revision}}} }},");
                }
                else
                {
                    sb.AppendLine($"            {{ L\"{kvp.Key}\", {{auto_major, 0, 0, 0}} }},");
                }
            }
            sb.AppendLine("        }},");
        }

        return sb.ToString()
            .AsSpan() // Optimisation for following string manipulations
            .Trim() // Remove whitespaces
            .TrimEnd(',') // Remove trailing comma
            .ToString();
    }
}
